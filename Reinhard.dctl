#line 2 "dynamic_range_compressor.dctl"

// add ui elements for upper and lower bounds
DEFINE_UI_PARAMS(lower, lower, DCTLUI_SLIDER_FLOAT, 2.0, -20.0, 20.0, 0.5)
DEFINE_UI_PARAMS(upper, upper, DCTLUI_SLIDER_FLOAT, 2.0, -20.0, 20.0, 0.5)
DEFINE_UI_PARAMS(key, key, DCTLUI_SLIDER_FLOAT, 0.3, 0.1, 0.6, 0.01)
DEFINE_UI_PARAMS(x_sample, x_sample, DCTLUI_SLIDER_INT, 1, 1, 20, 1)
DEFINE_UI_PARAMS(y_sample, y_sample, DCTLUI_SLIDER_INT, 1, 1, 20, 1)
DEFINE_UI_PARAMS(method, Clip, DCTLUI_CHECK_BOX, 0)


// Function to clip values to the gamut
__DEVICE__ float3 simpleClip(float3 color, float3 minGamut, float3 maxGamut) {
    color.x = clamp(color.x, minGamut.x, maxGamut.x);
    color.y = clamp(color.y, minGamut.y, maxGamut.y);
    color.z = clamp(color.z, minGamut.z, maxGamut.z);
    return color;
}

// Function to convert RGB to XYZ
__DEVICE__ float3 rgbToXyz(float3 color) {
    float3 xyz;
    // Linearize the RGB values
    color.x = (color.x > 0.04045) ? pow((color.x + 0.055) / 1.055, 2.4) : (color.x / 12.92);
    color.y = (color.y > 0.04045) ? pow((color.y + 0.055) / 1.055, 2.4) : (color.y / 12.92);
    color.z = (color.z > 0.04045) ? pow((color.z + 0.055) / 1.055, 2.4) : (color.z / 12.92);

    // Apply the RGB to XYZ conversion matrix
    xyz.x = 0.4124564 * color.x + 0.3575761 * color.y + 0.1804375 * color.z;
    xyz.y = 0.2126729 * color.x + 0.7151522 * color.y + 0.0721750 * color.z;
    xyz.z = 0.0193339 * color.x + 0.1191920 * color.y + 0.9503041 * color.z;

    return xyz;
}

// Function to convert XYZ to Lab
__DEVICE__ float3 xyzToLab(float3 xyz) {
    float3 lab;
    xyz.x = xyz.x / 0.95047;
    xyz.z = xyz.z / 1.08883;

    xyz.x = (xyz.x > 0.008856) ? pow(xyz.x, 1.0 / 3.0) : (7.787 * xyz.x) + (16.0 / 116.0);
    xyz.y = (xyz.y > 0.008856) ? pow(xyz.y, 1.0 / 3.0) : (7.787 * xyz.y) + (16.0 / 116.0);
    xyz.z = (xyz.z > 0.008856) ? pow(xyz.z, 1.0 / 3.0) : (7.787 * xyz.z) + (16.0 / 116.0);

    lab.x = (116.0 * xyz.y) - 16.0;
    lab.y = 500.0 * (xyz.x - xyz.y);
    lab.z = 200.0 * (xyz.y - xyz.z);
    return lab;
}

// Function to convert Lab to XYZ
__DEVICE__ float3 labToXyz(float3 lab) {
    float y = (lab.x + 16.0) / 116.0;
    float x = lab.y / 500.0 + y;
    float z = y - lab.z / 200.0;

    float3 xyz;
    xyz.x = 0.95047 * ((x * x * x > 0.008856) ? (x * x * x) : ((x - 16.0 / 116.0) / 7.787));
    xyz.y = (y * y * y > 0.008856) ? (y * y * y) : ((y - 16.0 / 116.0) / 7.787);
    xyz.z = 1.08883 * ((z * z * z > 0.008856) ? (z * z * z) : ((z - 16.0 / 116.0) / 7.787));
    return xyz;
}

// Function to convert XYZ to RGB
__DEVICE__ float3 xyzToRgb(float3 xyz) {
    float3 rgb;
    rgb.x =  3.2404542 * xyz.x - 1.5371385 * xyz.y - 0.4985314 * xyz.z;
    rgb.y = -0.9692660 * xyz.x + 1.8760108 * xyz.y + 0.0415560 * xyz.z;
    rgb.z =  0.0556434 * xyz.x - 0.2040259 * xyz.y + 1.0572252 * xyz.z;
    return rgb;
}

// Reinhard tone mapping function
__DEVICE__ float reinhard(float value, float key, float peakLuminance) {
    float scaledValue = value * key;
    return (scaledValue * (1.0 + scaledValue / (peakLuminance * peakLuminance))) / (1.0 + scaledValue);
}

// Main transform function
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB)
{
    // Variables to hold the peak luminance
    float peakLuminance = 0.0;

    // Only calculate the peak luminance if we are processing pixel (0,0)
    if (p_X == 0 && p_Y == 0)
    {
        for (int y = 0; y < p_Height; y += y_sample)
        {
            for (int x = 0; x < p_Width; x += x_sample)
            {
                float r = _tex2D(p_TexR, x, y);
                float g = _tex2D(p_TexG, x, y);
                float b = _tex2D(p_TexB, x, y);

                float3 color = make_float3(r, g, b);
                float3 xyz = rgbToXyz(color);
                float3 lab = xyzToLab(xyz);

                float luminance = lab.x;

                if (luminance > peakLuminance)
                {
                    peakLuminance = luminance;
                }
            }
        }

        // Store the peak luminance in pixel (0,0)
        return make_float3(peakLuminance, peakLuminance, peakLuminance);
    }
    else
    {
        // Fetch the peak luminance stored in pixel (0,0)
        float peakLuminance = _tex2D(p_TexR, 0, 0); // Assuming peak luminance is stored in the red channel of pixel (0,0)

        // Fetch the RGB values of the current pixel
        float r = _tex2D(p_TexR, p_X, p_Y);
        float g = _tex2D(p_TexG, p_X, p_Y);
        float b = _tex2D(p_TexB, p_X, p_Y);

        float3 color = make_float3(r, g, b);
        float3 xyz = rgbToXyz(color);
        float3 lab = xyzToLab(xyz);

        // Apply Reinhard tone mapping to the luminance
        lab.x = reinhard(lab.x, key, peakLuminance);

        // Convert back to RGB
        xyz = labToXyz(lab);
        float3 mappedColor = xyzToRgb(xyz);

        // Apply simple clipping for gamut compression
        float3 minGamut = make_float3(0.0, 0.0, 0.0); // Assume the target gamut minimum is 0
        float3 maxGamut = make_float3(1.0, 1.0, 1.0); // Assume the target gamut maximum is 1

        float3 result;
        switch (method) {
            case 1:
                result = simpleClip(mappedColor, minGamut, maxGamut);
                break;
            // Add other methods if needed
            default:
                result = mappedColor; // No additional gamut compression
                break;
        }
        return result;
    }
}
